// Mantid Repository : https://github.com/mantidproject/mantid
//
// Copyright &copy; 2018 ISIS Rutherford Appleton Laboratory UKRI,
//   NScD Oak Ridge National Laboratory, European Spallation Source,
//   Institut Laue - Langevin & CSNS, Institute of High Energy Physics, CAS
// SPDX - License - Identifier: GPL - 3.0 +
#include "MantidCudaAlgorithms/Algorithms/CudaMonteCarloAbsorption.h"

#include <cuda_runtime.h>

#include "MantidAPI/InstrumentValidator.h"
#include "MantidAPI/WorkspaceUnitValidator.h"
#include "MantidCudaAlgorithms/Algorithms/SampleCorrections/CudaMCAbsorptionSetup.h"
#include "MantidCudaAlgorithms/Algorithms/SampleCorrections/CudaMCAbsorptionStrategy.h"
#include "MantidCudaAlgorithms/CudaAlgorithmContext.h"
#include "MantidCudaAlgorithms/CudaGuard.h"
#include "MantidDataObjects/Workspace2D.h"
#include "MantidDataObjects/WorkspaceCreation.h"
#include "MantidKernel/BoundedValidator.h"
#include "MantidKernel/CompositeValidator.h"


/// @cond
namespace {

constexpr int DEFAULT_BLOCK_SIZE = 32;
constexpr int MAX_BLOCK_SIZE = 256;
constexpr int DEFAULT_NEVENTS = 300;
constexpr int DEFAULT_SEED = 123456789;
constexpr int DEFAULT_LATITUDINAL_DETS = 5;
constexpr int DEFAULT_LONGITUDINAL_DETS = 10;
constexpr int DEFAULT_GEOMETRY_BUFFER = 5;

} // namespace
/// @endcond

namespace Mantid {

using namespace API;
using DataObjects::Workspace2D;

namespace CudaAlgorithms {

DECLARE_ALGORITHM(CudaMonteCarloAbsorption)

//------------------------------------------------------------------------------
// Private methods
//------------------------------------------------------------------------------

/**
 * Initialize the algorithm
 */
void CudaMonteCarloAbsorption::init() {
  // The input workspace must have an instrument and units of wavelength
  auto wsValidator = std::make_shared<CompositeValidator>();
  wsValidator->add<WorkspaceUnitValidator>("Wavelength");
  wsValidator->add<InstrumentValidator>();

  declareProperty(std::make_unique<WorkspaceProperty<>>(
                      "InputWorkspace", "", Direction::Input, wsValidator),
                  "The name of the input workspace.  The input workspace must "
                  "have X units of wavelength.");
  declareProperty(std::make_unique<WorkspaceProperty<>>("OutputWorkspace", "",
                                                        Direction::Output),
                  "The name to use for the output workspace.");
  auto positiveInt = std::make_shared<Kernel::BoundedValidator<int>>();
  positiveInt->setLower(1);
  declareProperty("EventsPerPoint", DEFAULT_NEVENTS, positiveInt,
      "The number of \"neutron\" events to generate per simulated point");

  declareProperty("SeedValue", DEFAULT_SEED, positiveInt,
                  "Seed the random number generator with this value");

  // Control the number of attempts made to generate a random point in the
  // object
  declareProperty("MaxScatterPtAttempts", 5000, positiveInt,
                  "Maximum number of tries made to generate a scattering point "
                  "within the sample (+ optional container etc). Objects with "
                  "holes in them, e.g. a thin annulus can cause problems "
                  "if this number is too low.\n"
                  "If a scattering point cannot be generated by increasing "
                  "this value then there is most likely a problem with "
                  "the sample geometry.");

  declareProperty("GeometryBuffer", DEFAULT_GEOMETRY_BUFFER, positiveInt,
                  "Maximum number of elements in the geometry buffer, complex "
                  "objects may need a larger buffer. Increasing the geometry "
                  "buffer will result in a greater launch overhead with a "
                  "larger amount of memory utilized. Therefore, this value "
                  "should be minimized.");

  auto positiveMax256Int = std::make_shared<Kernel::BoundedValidator<int>>();
  positiveMax256Int->setLower(1);
  positiveMax256Int->setUpper(256);
  declareProperty("KernelBlockSize", DEFAULT_BLOCK_SIZE, positiveMax256Int,
                  "The block size the CUDA Kernel should to use for this "
                  "algorithm, defaults to 32. Ensure the value is a multiple "
                  "of 32. Maximum value is 256 to support use of MTGP32.");
}

/**
 * Execution code
 */
void CudaMonteCarloAbsorption::exec() {
  const MatrixWorkspace_sptr inputWS = getProperty("InputWorkspace");
  const int seed = getProperty("SeedValue");

  const int blockSize = getProperty("KernelBlockSize");
  const int nevents = getProperty("EventsPerPoint");
  const int maxScatterPtAttempts = getProperty("MaxScatterPtAttempts");
  const int geometryBuffer = getProperty("GeometryBuffer");

  MatrixWorkspace_uptr outputWS;

  switch (inputWS->getEMode()) {
    case DeltaEMode::Direct:
      outputWS = doSimulation<DeltaEMode::Direct>(*inputWS,
                                                  nevents,
                                                  seed,
                                                  maxScatterPtAttempts,
                                                  blockSize,
                                                  geometryBuffer);
      break;

    case DeltaEMode::Indirect:
      outputWS = doSimulation<DeltaEMode::Indirect>(*inputWS,
                                                    nevents,
                                                    seed,
                                                    maxScatterPtAttempts,
                                                    blockSize,
                                                    geometryBuffer);
      break;

    case DeltaEMode::Elastic:
      outputWS = doSimulation<DeltaEMode::Elastic>(*inputWS,
                                                   nevents,
                                                   seed,
                                                   maxScatterPtAttempts,
                                                   blockSize,
                                                   geometryBuffer);
      break;

    default: throw std::runtime_error("DeltaEMode not recognised");
  }

  setProperty("OutputWorkspace", std::move(outputWS));

  // Ensure everything is tidy
  CUDA_SOFT_GUARD(cudaDeviceReset());
}

/**
 * Run the simulation over the whole input workspace
 * @param inputWS A reference to the input workspace
 * @param nevents Number of MC events per wavelength point to simulate
 * @param nlambda Number of wavelength points to simulate. The remainder
 * are computed using interpolation
 * @param seed Seed value for the random number generator
 * @param interpolateOpt Method of interpolation to compute unsimulated points
 * @param useSparseInstrument If true, use sparse instrument in simulation
 * @param maxScatterPtAttempts The maximum number of tries to generate a
 * scatter point within the object
 * @return A new workspace containing the correction factors & errors
 */
template<DeltaEMode::Type etype>
MatrixWorkspace_uptr CudaMonteCarloAbsorption::doSimulation(
    const MatrixWorkspace &inputWS,
    const unsigned int nevents,
    const int seed,
    const unsigned int maxScatterPtAttempts,
    const unsigned int blockSize,
    const unsigned int geometryBuffer) {

  auto outputWS = createOutputWorkspace(inputWS);

  MatrixWorkspace &simulationWS = *outputWS;

  // Cache information about the workspace that will be used repeatedly
  const unsigned int nhists =
          static_cast<unsigned int>(simulationWS.getNumberHistograms());
  const unsigned int nbins =
          static_cast<unsigned int>(simulationWS.blocksize());

  if (blockSize % 32 != 0) {
    g_log.warning() << "Block size is not a multiple of 32, this can lead to "
                       "suboptimal performance. Consider rounding up/down to "
                       "the nearest multiple of 32." << std::endl;
  }

  // Configure progress
  Progress prog(this, 0.0, 1.0, static_cast<size_t>(nbins * nhists + 1));
  prog.setNotifyStep(0.01);
  prog.report("Configuring CUDA device");

  // create the algorithm stream for processing setup and MonteCarlo kernel
  cudaStream_t algorithmStream;
  CUDA_GUARD(cudaStreamCreate(&algorithmStream));

  CudaAlgorithmContext context;
  cudaDeviceProp deviceProperties;
  CUDA_GUARD(cudaGetDeviceProperties(&deviceProperties, 0));


  CudaMCAbsorptionSetup<etype> setup(simulationWS, context, nhists, nbins,
                                     nevents, blockSize, maxScatterPtAttempts,
                                     geometryBuffer, seed, deviceProperties,
                                     algorithmStream);
  CudaMCAbsorptionParameters<etype> d_params = setup.getDeviceParams();

  CudaMCAbsorptionStrategy<etype> strategy(d_params);

  strategy.calculate(algorithmStream);

  const std::string corrString = "Computing corrections";

  // set error whilst kernel is running
  for (unsigned long i = 0; i < nhists; ++i) {
    std::fill(simulationWS.mutableE(i).begin(),
              simulationWS.mutableE(i).end(), 1 / std::sqrt(nevents));
  }

  while (cudaStreamQuery(algorithmStream) == cudaErrorNotReady) {
    if (prog.hasCancellationBeenRequested()) {
      context.cancel();
      cudaStreamSynchronize(algorithmStream);
      interruption_point();
    }

    prog.report(context.getProgress(), corrString);
  }

  // ensure the kernel did not bottle
  CUDA_GUARD(cudaGetLastError());

  const size_t histOutputSize = sizeof(double) * nbins;
  for (unsigned long i = 0; i < nhists; i++) {
    auto &outY = simulationWS.mutableY(i);

    CUDA_GUARD(cudaMemcpy(&outY[0],
                          d_params.output + (i * nbins),
                          histOutputSize,
                          cudaMemcpyDeviceToHost));
    std::transform(outY.begin(),
                   outY.end(),
                   outY.begin(),
                   std::bind(std::divides<double>(),
                             std::placeholders::_1,
                             nevents)
                   );
  }

  return outputWS;
}

MatrixWorkspace_uptr CudaMonteCarloAbsorption::createOutputWorkspace(
    const MatrixWorkspace &inputWS) const {
  MatrixWorkspace_uptr outputWS = DataObjects::create<Workspace2D>(inputWS);
  // The algorithm computes the signal values at bin centres so they should
  // be treated as a distribution
  outputWS->setDistribution(true);
  outputWS->setYUnit("");
  outputWS->setYUnitLabel("Attenuation factor");
  return outputWS;
}

}
}
